<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>算法和数据结构 | Mosthink</title>
  <meta name="author" content="Viyu">
  
  <meta name="description" content="几个对数组的算法
1， 找出数组中的最大值：
1
2
3
4
5
double max = a[0];

for(int i = 1; i &amp;lt; a.length; i++)

    if(a[i] &amp;gt; max) max = a[i];


//把最大值马上设定为数组的第一个元素，然后遍历数组，如果有别当前这个最大值更大的元素，则把最大值更新，直到遍历结束；
2， 计算数组的平均值：
1
2
3
4
5
6
7
double sum = 0.0;

for(int i = 0; i &amp;lt; a.length; i++)

    sum += a[i];

double average = sum / a.length;


//算出总值，然后除以数组的元素数；
3，复制数组：
1
2
3
4
5
6
7
double[] b = new double[a.length];

for(int i = 0; i &amp;lt; a.length; i++) 

    b[i] = a[i];

//new 一个和原数组同length同类型的数组，然后遍历赋值每个元素；


4，颠倒数组元素的顺序：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
double [] b = new double[a.length];

for(int i = a.length - 1, j = 0; i &amp;gt; -1 &amp;amp;&amp;amp; j &amp;lt; b.length ; i--, j++) 

    b[j] = a[i];

//这是个直观低效率算法，时间消耗(a.length)，空间消耗(2 * a.length)，并且有两个循环指数i, j；

for(int i =0; i &amp;lt; a.length / 2; i++) {

    double temp = a[i];

    a[i] = a[a.length - 1 - i];

    a[a.length - 1 - i] = temp;
}">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="算法和数据结构"/>
  <meta property="og:site_name" content="Mosthink"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Mosthink" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Mosthink</a></h1>
  <h2><a href="/">Viyu&#39;s Blog</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2009-07-02T00:00:00.000Z"><a href="/2009/07/02/2009-07-02-sfsjjg/">Jul 2 2009</a></time>
      
      
  
    <h1 class="title">算法和数据结构</h1>
  

    </header>
    <div class="entry">
      
        <p><b>几个对数组的算法</b></p>
<p>1， 找出数组中的最大值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">double</span> <span class="built_in">max</span> = a[<span class="number">0</span>];

<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">length</span>; i++)

    <span class="keyword">if</span>(a[i] &gt; <span class="built_in">max</span>) <span class="built_in">max</span> = a[i];
</pre></td></tr></table></figure>

<p>//把最大值马上设定为数组的第一个元素，然后遍历数组，如果有别当前这个最大值更大的元素，则把最大值更新，直到遍历结束；</p>
<p>2， 计算数组的平均值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">double</span> <span class="keyword">sum</span> = <span class="number">0.0</span>;

<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)

    <span class="keyword">sum</span> += a[i];

<span class="keyword">double</span> average = <span class="keyword">sum</span> / a.length;
</pre></td></tr></table></figure>

<p>//算出总值，然后除以数组的元素数；</p>
<p>3，复制数组：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">double</span>[] b = new <span class="keyword">double</span>[a.<span class="built_in">length</span>];

<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>; i++) 

    b[i] = a[i];

<span class="comment">//new 一个和原数组同length同类型的数组，然后遍历赋值每个元素；</span>
</pre></td></tr></table></figure>

<p>4，颠倒数组元素的顺序：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">double</span> [] b = new <span class="keyword">double</span>[a.<span class="built_in">length</span>];

<span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">length</span> - <span class="number">1</span>, j = <span class="number">0</span>; i &gt; -<span class="number">1</span> &amp;&amp; j &lt; b.<span class="built_in">length</span> ; i--, j++) 

    b[j] = a[i];

<span class="comment">//这是个直观低效率算法，时间消耗(a.length)，空间消耗(2 * a.length)，并且有两个循环指数i, j；</span>

<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; a.<span class="built_in">length</span> / <span class="number">2</span>; i++) {

    <span class="keyword">double</span> temp = a[i];

    a[i] = a[a.<span class="built_in">length</span> - <span class="number">1</span> - i];

    a[a.<span class="built_in">length</span> - <span class="number">1</span> - i] = temp;
}
</pre></td></tr></table></figure>

<a id="more"></a>

<p>偶数个元素的交换过程：</p>
<p>&lt; 2            1, 2, 3, 4</p>
<p>0                4, 2, 3, 1</p>
<p>1                4, 3, 2, 1</p>
<p>奇数个元素的交换过程：</p>
<p>&lt; 2            1, 2, 3, 4, 5</p>
<p>0                5, 2, 3, 4, 1</p>
<p>1                5, 4, 3, 2, 1</p>
<p>//可见，无论是偶数个还是奇数个元素，交换的次数都一样，都是a.length/2，偶数个的时候是全交换，奇数个的时候，是以中间的那个元素为中心点，其他元素都交换，中间元素并不在a.length/2的遍历范围内；这个算法，时间(a.length/2)，空间(a.length)；</p>
<p>5，a[][] * b[][] = c[][]， 矩阵相乘（方阵）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>int n = a.length;

double[<span class="link_label"></span>][<span class="link_reference"></span>] c = new double[<span class="link_label">n</span>][<span class="link_reference">n</span>];

for(int i = 0; i <span class="xml"><span class="tag">&lt; <span class="attribute">n</span>; <span class="attribute">i</span>++)

    <span class="attribute">for</span> (<span class="attribute">int</span> <span class="attribute">j</span> = <span class="attribute">0</span>; <span class="attribute">j</span> &lt; <span class="attribute">n</span>; <span class="attribute">j</span>++) {

        <span class="attribute">for</span>(<span class="attribute">int</span> <span class="attribute">k</span> = <span class="attribute">0</span>; <span class="attribute">k</span> &lt; <span class="attribute">n</span>; <span class="attribute">k</span>++) //计算行<span class="attribute">i</span>和列<span class="attribute">j</span>的点乘

            <span class="attribute">c</span>[<span class="attribute">i</span>][<span class="attribute">j</span>] += <span class="attribute">a</span>[<span class="attribute">i</span>][<span class="attribute">k</span>] * <span class="attribute">b</span>[<span class="attribute">k</span>][<span class="attribute">j</span>];

    }</span></span>
</pre></td></tr></table></figure>

<hr>
<p><b>典型静态方法的实现</b></p>
<p>1，计算整数的绝对值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span>(<span class="keyword">int</span> x) {
    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)    <span class="keyword">return</span> -x;

    <span class="keyword">else</span>    <span class="keyword">return</span> x;
}
</pre></td></tr></table></figure>

<p>//绝对值的规则很简单：不小于零就是本身，反之就返回-x；</p>
<p>2， 计算浮点数的绝对值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span>(<span class="keyword">double</span> x) {
    <span class="keyword">if</span>( x &lt; <span class="number">0.0</span>)    <span class="keyword">return</span> -x;

    <span class="keyword">else</span>    <span class="keyword">return</span> x;
}
</pre></td></tr></table></figure>

<p>3， 判断一个数是否是素数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span>(<span class="keyword">int</span> n) {
    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)    <span class="keyword">return</span> <span class="keyword">false</span>;                        <span class="comment">//大于1的自然数，1不是素数</span>

    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) {              <span class="comment">//i * i &lt;=n</span>

        <span class="keyword">if</span>(n % i == <span class="number">0</span>)    <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</pre></td></tr></table></figure>

<p>//素数，就是质数。指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。</p>
<p>判断的关键点：</p>
<p>a,  小于2，不是；</p>
<p>b，从2到n遍历，遍历到一个i <em> i &gt; n之前的数就提前结束遍历，因为2到满足i </em> i &lt;= n的i之间的这些数如果能整除n，那么i之后到n的这些数也能；以满足i * i &lt;=n为分界线，1…n之间的数对于整除n来说，是对称的；</p>
<p>判断n能否被i整除：n % i 的值是否为0；</p>
<p>4， 计算平方根（牛顿迭代法）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span>(<span class="keyword">double</span> c) {

    <span class="keyword">if</span>(c &lt; <span class="number">0</span>) <span class="keyword">return</span> Double.NaN;

    <span class="keyword">double</span> err =<span class="number">1e-15</span>;                 <span class="comment">//1乘以10的负15次方</span>

    <span class="keyword">double</span> t = c;

    <span class="keyword">while</span>(Math.abs(t - c / t) &gt; err *t)

        t = (c/t + t) / <span class="number">2.0</span>;
    <span class="keyword">return</span> t;
}
</pre></td></tr></table></figure>

<p>//不懂， TODO</p>
<p>5， 计算直角三角形的斜边：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">hypotenuse</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {

    <span class="keyword">return</span> Math.sqrt(a * a + b * b);
}
</pre></td></tr></table></figure>

<p>6， 计算调和级数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> H(<span class="keyword">int</span> n) {

    <span class="keyword">double</span> <span class="keyword">sum</span> = <span class="number">0.0</span>;

    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) 

        <span class="keyword">sum</span> += <span class="number">1.0</span> / i;

    <span class="keyword">return</span> <span class="keyword">sum</span>;
}
</pre></td></tr></table></figure>

<p>//形如1/1+1/2+1/3+…+1/n+…的级数称为调和级数，它是 p=1 的p级数。 调和级数是发散级数。在n趋于无穷时其部分和没有极限（或部分和为无穷大）。</p>
<hr>
<p><b>二分查找的递归和循坏实现法</b></p>
<p>递归总有一个最简单的情况-方法的第一条语句总是包含return的条件语句；</p>
<p>递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况;</p>
<p>递归调用的父问题和尝试解决的子问题之间不应该有交集；</p>
<p>二分查找：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rank</span>(<span class="keyword">int</span> key, <span class="keyword">int</span>[] a) {

    <span class="keyword">return</span> rank(key, a, <span class="number">0</span>, a.length - <span class="number">1</span>);

}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rank</span>(<span class="keyword">int</span> key, <span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi) {

    <span class="keyword">if</span>(lo &gt; hi)

        <span class="keyword">return</span> -<span class="number">1</span>;

    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;   <span class="comment">//数组并没有被拆分，所以这里(hi - lo)/2必须再加上lo</span>

    <span class="keyword">if</span>(key &lt; a[mid])     <span class="keyword">return</span> rank(key, a, lo, mid - <span class="number">1</span>);

    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid]     <span class="keyword">return</span> rank(key, a, mid +<span class="number">1</span>, hi);

    <span class="keyword">else</span>     <span class="keyword">return</span> mid;
}
</pre></td></tr></table></figure>

<p>//如果原始的方法参数不怎么适合递归或者不够递归方法，就另写一个满足要求的递归方法，用原始的调用之；</p>
<p>比如二分查找的时候，并没有给定递归时需要的低坐标和高坐标，如果坚持要在原始方法中使用递归，那么必须对数组进行拆分和复制，效率低下，浪费空间；</p>
<p>在不拆分数组的情况下，“父问题和子问题之间不应该有交集“， 所以mid不是简单的lo + hi /2了；mid不用再被传给子问题，因为== mid的话就是解了已经，低位传lo到mid-1；高位传mid + 1到hi；</p>
<hr>
<p>循环实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">int</span> lo = <span class="number">0</span>;

<span class="keyword">int</span> hi = a.<span class="built_in">length</span> - <span class="number">1</span>;

<span class="keyword">while</span>(lo &lt;= hi) {

    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>; <span class="comment">//不拆分数组的话，始终是这个公式</span>

    <span class="keyword">if</span>(key &lt; a[mi])     hi = mid - <span class="number">1</span>;

    <span class="keyword">if</span>(key &gt; a[mi])     lo = mid + <span class="number">1</span>;

    <span class="keyword">else</span>     <span class="keyword">return</span> mid;
}

<span class="keyword">return</span> -<span class="number">1</span>;
</pre></td></tr></table></figure>

<hr>
<p><b>不用temp实现swap</b></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="literal">a</span> = <span class="literal">a</span> + b<span class="comment">;</span>

b = <span class="literal">a</span> - b<span class="comment">;</span>

<span class="literal">a</span> = <span class="literal">a</span> - b<span class="comment">;</span>
</pre></td></tr></table></figure>

<hr>
<p><b>Dijkstra双栈算术表达式求值法</b></p>
<p>双栈：一个操作数栈，一个操作符栈；</p>
<p>从左到有遍历算数表达式：</p>
<p>1， 忽略左括号；</p>
<p>2， 将数字push入操作数栈；</p>
<p>3， 将运算符push入操作符栈；</p>
<p>4， 遇到有括号时，pop一个运算符，pop出所需数量的操作数，并将运算符和操作数的运算结果push入操作数栈。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="code"><pre>public static double calc(String[] equation) {

    Stack&lt;String&gt; ops = new Stack&lt;String&gt;();

    Stack&lt;Double&gt; vals = new Stack&lt;Double&gt;();

    <span class="keyword">for</span>(String s : equation) {

        <span class="keyword">if</span>(s.<span class="keyword">equals</span>(<span class="string">"("</span>))

            ;

        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="keyword">equals</span>(<span class="string">"+"</span>))

            ops.push(s);

        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="keyword">equals</span>(<span class="string">"-"</span>))

            ops.push(s);

        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="keyword">equals</span>(<span class="string">"*"</span>))

            ops.push(s);

        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="keyword">equals</span>(<span class="string">"/"</span>))

            ops.push(s);

        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="keyword">equals</span>(<span class="string">"sqrt"</span>))

            ops.push(s);

        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="keyword">equals</span>(<span class="string">")"</span>)) {

            String op = ops.pop();

            double v = vals.pop();

            <span class="keyword">if</span>(op.<span class="keyword">equals</span>(<span class="string">"+"</span>)) 

                v = vals.pop() + v;

            <span class="keyword">if</span>(op.<span class="keyword">equals</span>(<span class="string">"-"</span>)) 

                v = vals.pop() - v;

            <span class="keyword">if</span>(op.<span class="keyword">equals</span>(<span class="string">"*"</span>)) 

                v = vals.pop() * v;

            <span class="keyword">if</span>(op.<span class="keyword">equals</span>(<span class="string">"/"</span>)) 

                v = vals.pop() / v;

            <span class="keyword">if</span>(op.<span class="keyword">equals</span>(<span class="string">"sqrt"</span>)) 

                v = Math.sqrt(v);

            vals.push(v);

        } <span class="keyword">else</span>

            vals.push(Double.parseDouble(s));

    }
<span class="command">
    return</span> vals.pop();
}
</pre></td></tr></table></figure>

<p>这其实就是编译原理中的解释器。</p>
<p>应该也有其他方法，比如全部push入栈之后再依次出栈，前提是优先级用括号来明示。</p>
<hr>
<p><b>堆栈的数组和链表实现以及队列的链表实现</b></p>
<p>堆栈的意义：</p>
<p>堆栈并不是为了迭代的一个容器，虽然它是一个可迭代的容器，但它不应该被应用于静态的数据存储场景；</p>
<p>堆栈应该应用于动态的运算、过滤等场景；</p>
<p>创建泛型类型的数组作为数据存储：</p>
<p>直接创建泛型数组是不可以的：T[] items = new T[2];</p>
<p>只能通过这种方式创建：T[] items = (T[])(new Object[2]);</p>
<p>动态增减数组大小：</p>
<p>动态增减的数组实现：没有高深的方法，就是new一个新的数组，把值拷贝过来，再把引用赋予新的数组对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>T[] temp = (T[]) <span class="keyword">new</span> <span class="built_in">Object</span>[newLength];

<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)     <span class="comment">//如果是减小数组，这里的条件需要修改</span>

    temp[i] = a[i];

a = temp;
</pre></td></tr></table></figure>

<p>增：当数组满的时候，直接增加1倍；</p>
<p>减：当数组不满1/4的时候，减少至1/2；</p>
<p>以上是基于内存开销和性能之间的平衡，尤其是缩减数组，不能一个一个减，也不能不满1/2的时候直接减掉1/2，这样数组马上又满了，可能又需要增。</p>
<p>Stack内部使用动态增减的数组后，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(T item) {

    <span class="keyword">if</span>(N == a.length)

        resize(<span class="number">2</span> * a.length)

    a[N++] = item;

}

<span class="keyword">public</span> T <span class="title">pop</span>() {

    T item = a[--N];

    a[N] = <span class="keyword">null</span>;  

    <span class="keyword">if</span>(N &gt; <span class="number">0</span> &amp;&amp; N == a.length / <span class="number">4</span>) <span class="comment">//如果堆栈只满1/4，减为1/2，还能有1/2的空余；</span>

        resize(a.length / <span class="number">2</span>);

    <span class="keyword">return</span> item;
}
</pre></td></tr></table></figure>

<p>pop()方法中要避免内存泄漏：</p>
<p>对象游离： Stack的pop方法写的不好，就有可能导致内存泄漏；</p>
<p>用数组实现堆栈，pop之后，当前对象在堆栈范围内已经无用了，如果客户代码那也用完了这个对象，其该被回收，但是，因为Stack内部的数组还有对这个对象的引用，导致无法被GC，除非再次push，该数组位的引用值被重新指向另一个对象，原来那个对象就被GC了；</p>
<p>如果用API中的List实现堆栈，因为List本身的remove方法已经采取了避免对象游离的措施，所以就没这个问题；</p>
<p>用数组存储和用链表存储：</p>
<p>堆栈本身并不用于遍历，所以操作（push和pop）的用时都跟集合大小无关，不管是用数组还是用链表实现；</p>
<p>用数组存储的明显缺点就在于，push，pop会不定期地引起数组的调整，调整数组的耗时和栈大小成正比，克服这个缺陷就是用链表代替之：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="keyword">private</span> Node first = <span class="keyword">null</span>; <span class="comment">//栈顶节点</span>

<span class="keyword">private</span> Class Node { <span class="comment">//描述栈帧的节点内部类定义</span>

    T item;

    Node next;

}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(T item) {

    Node oldFirst = first;

    first = <span class="keyword">new</span> Node();

    first.item = item;

    first.next = oldFirst;

    N++;

}

<span class="keyword">public</span> T <span class="title">pop</span>() {

    T item = first.item;

    first = first.next();

    N--;

    <span class="keyword">return</span> item;
}
</pre></td></tr></table></figure>

<p>不用担心对象游离的问题，first = first.next之后，由于堆栈里并没有数组结构，出栈的对象在栈内不会再被引用，没用就回收掉了；</p>
<p>堆栈也是集合，也要实现迭代器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>Stack&lt;<span class="literal">T</span>&gt; implements Iterable&lt;<span class="literal">T</span>&gt;

public Iterator&lt;<span class="literal">T</span>&gt; iterator() {

    <span class="keyword">return</span> new Iterator&lt;<span class="literal">T</span>&gt; {

        private int i = N;

        public boolean hasNext() {

            <span class="keyword">return</span> i &gt; <span class="number">0</span>;

        }

        public <span class="literal">T</span> <span class="keyword">next</span>() {

            <span class="keyword">return</span> a[--i];

        }

        <span class="keyword">...</span>

    }
</pre></td></tr></table></figure>

<p>链表实现的迭代：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>Stack&lt;<span class="literal">T</span>&gt; implements Iterable&lt;<span class="literal">T</span>&gt;

public Iterator&lt;<span class="literal">T</span>&gt; iterator() {

    <span class="keyword">return</span> new Iterator&lt;<span class="literal">T</span>&gt; {

        private Node current = first;

        public boolean hasNext() {

            <span class="keyword">return</span> current != null;

        }

        public <span class="literal">T</span> <span class="keyword">next</span>() {

             <span class="literal">T</span> item = current.item;

            current = current.next;

            <span class="keyword">return</span> item;

        }

        <span class="keyword">...</span>

    }
</pre></td></tr></table></figure>

<p>链表实现的队列就是一种堆栈，仍然从first出队，但是从last入队：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>public <span class="type">boolean</span> isEmpty() {
<span class="command">
    return</span> <span class="keyword">first</span> === null;

}

public void enqueue(T <span class="property">item</span>) {

    Node oldLast = <span class="keyword">last</span>;

    <span class="keyword">last</span> = new Node();

    <span class="keyword">last</span>.<span class="property">item</span> = <span class="property">item</span>;

    <span class="keyword">last</span>.next = null;

    <span class="keyword">if</span>(isEmpty())

        <span class="keyword">first</span> = <span class="keyword">last</span>;

    <span class="keyword">else</span>

        oldLast.next = <span class="keyword">last</span>;

    N++;

}

public Item dequeue() {

    T <span class="property">item</span> = <span class="keyword">first</span>.<span class="property">item</span>;

    <span class="keyword">first</span> = <span class="keyword">first</span>.next;

    <span class="keyword">if</span>(isEmpty())

        <span class="keyword">last</span> = null;

    N<span class="comment">--;</span>
<span class="command">
    return</span> <span class="property">item</span>;
}
</pre></td></tr></table></figure>

<p>到底用数组还是链表：</p>
<p>堆栈是LIFO，数组实现的话，总是在数组的末尾进行赋值和置null，这个可以接受；但数组的调整大小问题导致数组实现又不是特别能接受，而链表就完全不存在这个问题；</p>
<p>队列是FIFO，数组实现的话，假如入队末尾，那么出队必然在开头，删除开头元素要引起数组整体挪动；或者反过来，入队在开头，则出队在末尾，入队得在开头添加元素，引起数组整体挪动；所以说，队列一点都不适合用数组实现。</p>
<hr>
<p>常数、对数、线性、线性对数、平方、立方、指数；</p>
<p>一般来说，平方、立方、指数级别的算法对于大规模的问题是不可用的；</p>
<p>logN的底数对算法分析来说相当于一个常数，所以可以忽略底数到底是几；</p>
<p>2-sum问题的平方级算法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">for</span>(int <span class="built_in">i</span> =<span class="number">0</span>; <span class="built_in">i</span> &lt; N; <span class="built_in">i</span>++) 

    <span class="keyword">for</span>(int <span class="built_in">j</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="built_in">j</span> &lt; N; <span class="built_in">j</span>++) 

        <span class="keyword">if</span>(a<span class="matrix">[i]</span> + a<span class="matrix">[j]</span> == <span class="number">0</span>)

            count++;
</pre></td></tr></table></figure>

<p>这个复杂度是(N-1) + (N-2) + … + (N-N) = N的平方 + N的平方/2 =-= N的平方；</p>
<p>改进的算法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>sort(a);

<span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; N; <span class="built_in">i</span>++) 

    <span class="keyword">if</span>(BinarySearch(-a<span class="matrix">[i]</span>, a) &gt; <span class="built_in">i</span>)

        count++;
</pre></td></tr></table></figure>

<p>这个算法的思路，单循环数组a，对于每一个a[i]：</p>
<p>1， 如果二分查找找不到-a[i]，计数器不增加；</p>
<p>2， 如果二分查找到的-a[i]是a[j]，如果j &gt; i，计数器增加，反之如果j &lt; i，因为a是排序了的，说明这次查找之前已经用a[j]找到过a[i]了，重复了，计算器不增加；</p>
<p>对于N次单循环，每次都二分查找了，二分查找的复杂度是对数级，所以这个算法的总复杂度是线性对数级；</p>
<p>相应的，原来为N的立方的3-sum问题可被优化为N的平方对数级的；</p>
<hr>
<p><b>优先队列的二叉堆实现</b></p>
<p>【优先队列】</p>
<p>堆栈：删除最新元素；</p>
<p>队列：删除最旧元素；</p>
<p>优先队列：删除最大元素和插入元素；</p>
<p>优先队列实现的两个方式：</p>
<p>1， 惰性的，使用无序数据结构，插入元素不做任何操作，删除最大元素时再查找最大元素；</p>
<p>2， 主动的，使用有序数据结构，插入元素时就排到合适的位置，删除最大元素时直接删第一个；</p>
<p>优先队列的初级实现：</p>
<pre><code>                        插入元素                        删除最大元素
</code></pre><p>有序数组                N                                    1</p>
<p>无序数组                1                                      N</p>
<p>栈和队列的操作的复杂度都是个常数；</p>
<p>优先队列用数组初级实现的话，操作的复杂度都是线性的；</p>
<p>我们试图探寻更好性能的优先队列实现；</p>
<p>【二叉堆】</p>
<p>用数组表示完全二叉树：</p>
<p>将二叉树的节点按照层级顺序放入数组中，根节点在位置1，它的子节点在位置2和3，而子节点的子节点则分别在4、5、6、7；</p>
<p>不使用数组的第一个位置；</p>
<p>对于一个节点，它在数组中的是索引是k，那么它的父节点的索引是：下取整(k/2)</p>
<p>子节点的索引分别是2k和2k+1；</p>
<p>堆有序：</p>
<p>当一棵二叉树的每个节点都大于等于它的两个子节点时；</p>
<p>在堆有序的二叉树中，从任意节点向上，都能得到一列非递减的元素；从任意节点向下，都能得到一列非递增的元素；</p>
<p>堆有序化-上浮：</p>
<p>如果堆的有序状态因为某个节点变得比它的父节点更大而打破，就需要交换它和它的父节点；</p>
<p>交换后，这个节点仍然可能比现在的父节点大，所以需要继续往上交换；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>void swim(<span class="keyword">int</span> k) {

    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; p<span class="string">q[k/2]</span> &lt; p<span class="string">q[k]</span>) {

        swap(pq, k/<span class="number">2</span>, k);

        k = k / <span class="number">2</span>;
}
</pre></td></tr></table></figure>

<p>同理，下沉：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>void sink(<span class="keyword">int</span> k) {

    <span class="keyword">while</span>(<span class="number">2</span> * k &lt;= N) {
        <span class="keyword">int</span> j = <span class="number">2</span> * k;

        <span class="keyword">if</span>(j &lt; N &amp;&amp; p<span class="string">q[j]</span> &lt; p<span class="string">q[j+1]</span>) //选取两个子节点中较大的一个往上交换

                j++;

        <span class="keyword">if</span>(p<span class="string">q[k]</span> &gt;= p<span class="string">q[j]</span>)   //结束下沉，已经比字节点大了

                <span class="keyword">break</span>;

        swap(pq, k, j); <span class="regexp">//</span>下沉

        k = j;
}
</pre></td></tr></table></figure>

<p>在实现二叉堆的数组中，插入一个数据到末尾是上浮；删除第一个数据，这个数据就是最大元素，然后把数组最末尾的元素放到顶端，让其下沉；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; {

    <span class="keyword">private</span> Key[] pq;

    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;

    <span class="keyword">public</span> <span class="title">MaxPQ</span>(<span class="keyword">int</span> maxN) {

        pq = (key[]) <span class="keyword">new</span> Comparable[maxN+<span class="number">1</span>];

    }

    <span class="keyword">public</span> boolean <span class="title">isEmpty</span>() {

        <span class="keyword">return</span> N == <span class="number">0</span>;

    }

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() {

        <span class="keyword">return</span> N;

    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(Key v) {

        pq[++N] = v;

        swim(N);

    }

    <span class="keyword">public</span> Key <span class="title">delMax</span>() {

        Key max = pq[<span class="number">1</span>];

        swap(<span class="number">1</span>, N--);

        pq[N+<span class="number">1</span>] = <span class="keyword">null</span>;

        sink(<span class="number">1</span>);

        <span class="keyword">return</span> max;

    }
}
</pre></td></tr></table></figure>

<p>由于插入和删除都最多是一次根节点到叶节点的堆秩序恢复，跟节点到叶节点的最长路径是lgN；所以二叉堆实现的优先队列的插入和删除的复杂度都是lgN（比较次数：lgN+1, 2lgN）；</p>
<hr>
<p><b>如何检测一个链表中是不是有循环结点？</b></p>
<p>两个指针，分别表示乌龟和兔子，乌龟每次往下走1步，兔子每次走两步，如果兔子走到了Next为Null的节点，说明没有循环，否则他们一定相遇，表示有循环。</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/Algorithm/">Algorithm</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://mosthink.net/2009/07/02/2009-07-02-sfsjjg/" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:mosthink.net">
  </form>
</div>

  

  <div class="widget tag">
  <h3 class="title">My Projects</h3>
  <ul class="entry">
 	<li><a href="http://mosthink.net/LockPattern" target="_blank">LockPattern</a></li>
    <li><a href="http://mosthink.net/ANotepad" target="_blank">ANotepad</a></li>
    <li><a href="http://mosthink.net/PushNewsmth2Mail" target="_blank">PushNewsmth2Mail</a></li>
    <li><a href="http://mosthink.net/DoubleFacedCamera" target="_blank">DoubleFacedCamera</a></li>
    <li><a href="http://mosthink.net/TransformersPuzzle" target="_blank">TransformersPuzzle</a></li>
    <li><a href="http://mosthink.net/BluetoothChat" target="_blank">BluetoothChat</a></li>
    <li><a href="http://mosthink.net/LianLianKan" target="_blank">LianLianKan</a></li>
  </ul>
</div>


  <div class="widget tag">
  <h3 class="title">My Codes(gist)</h3>
  <ul class="entry">
    <li><a href="https://gist.github.com/Viyu/8093281" target="_blank">DragAndDropDemo</a></li>
    <li><a href="https://gist.github.com/Viyu/8093389" target="_blank">LedLightDemo</a></li>
    <li><a href="https://gist.github.com/Viyu/d0df67fb40be217638a3" target="_blank">PingUtil</a></li>
    <li><a href="https://gist.github.com/Viyu/9406327" target="_blank">GPS utility</a></li>
    <li><a href="https://gist.github.com/Viyu/9521561" target="_blank">PopupWindow</a></li>
  </ul> 
</div>


  <div class="widget tag">
  <h3 class="title">Link</h3>
  <ul class="entry">
    <li><a href="http://haoffer.com" target="_blank">Haoffer.com</a></li>
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Algorithm/">Algorithm</a><small>2</small></li>
  
    <li><a href="/tags/Android/">Android</a><small>8</small></li>
  
    <li><a href="/tags/Android Dex/">Android Dex</a><small>1</small></li>
  
    <li><a href="/tags/Android ListView/">Android ListView</a><small>1</small></li>
  
    <li><a href="/tags/Android LockPattern/">Android LockPattern</a><small>1</small></li>
  
    <li><a href="/tags/Android ping/">Android ping</a><small>1</small></li>
  
    <li><a href="/tags/Annotation/">Annotation</a><small>1</small></li>
  
    <li><a href="/tags/Class/">Class</a><small>1</small></li>
  
    <li><a href="/tags/Concurrence/">Concurrence</a><small>1</small></li>
  
    <li><a href="/tags/Design/">Design</a><small>1</small></li>
  
    <li><a href="/tags/GPS/">GPS</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>3</small></li>
  
    <li><a href="/tags/Jvm/">Jvm</a><small>1</small></li>
  
    <li><a href="/tags/PopupWindow/">PopupWindow</a><small>1</small></li>
  
    <li><a href="/tags/javascript/">javascript</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Viyu
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>